#!/usr/bin/python3

# Copyright: (c) 2024, Orion Poplawski <orion@nwra.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

import argparse
import datetime
import git
import jinja2
import lxml.etree as ET
import lxml.html
import os
from paramiko import SSHClient
import re
import requests
from scp import SCPClient
import sys
import tempfile
from urllib.parse import urlparse

gitconfig = git.GitConfigParser()
author_name = gitconfig.get_value('user', 'name')
author_email = gitconfig.get_value('user', 'email')

parser = argparse.ArgumentParser(description='Generate a pfsensible module.')
parser.add_argument('--url', help='The URL to scrape')
parser.add_argument('--urlfile', help='A local file copy of the URL to scrape')
parser.add_argument('--user', default='admin', help='The user to connect as')
parser.add_argument('--password', default='changeme', help='The password of user')
parser.add_argument('--author-name', default=author_name, help='The full name of the module author')
parser.add_argument('--author-email', default=author_email, help='The email address of the module author')
parser.add_argument('--author-handle', default='', help='The github handle of the module author')
parser.add_argument('--module-name', help='The name of the module to generate - defaults to being based on the url')
parser.add_argument('--item-min', default='item_min', help='The name of the minimally configured item to search for in config.xml')
parser.add_argument('--item-full', default='item_full',
                    help='The name of the fully configured item to search for in config.xml, will be used for exmaples in the documentation')
parser.add_argument('--force', action=argparse.BooleanOptionalAction, help='Force overwriting the output file if it exists')
parser.add_argument('--keep', action=argparse.BooleanOptionalAction, help='Keep the downloaded files in the temporary directory')

args = parser.parse_args()

# Temporary directory for files
tmpdir = tempfile.TemporaryDirectory(prefix='pfgenmod-', delete=(not args.keep))

if args.url is not None:
    parsed_uri = urlparse(args.url)

    # Login using just the base URL
    login_url = '{uri.scheme}://{uri.netloc}/'.format(uri=parsed_uri)

    # Collect to host for later use to scp config.xml
    host = f'{parsed_uri.netloc}'

    # Construct a likely module name from the URL
    if args.module_name is None:
        module_name = re.sub(r'^/(?:firewall_|system_)?(.*?)(?:_edit)?\.php.*$', r'pfsense_\1', parsed_uri.path)
        module_name_singular = re.sub(r'ses$', 's', module_name)
        if module_name_singular != module_name:
            module_name = module_name_singular
        else:
            module_name = re.sub(r's$', '', module_name)
    else:
        module_name = args.module_name

    # We likely don't have a valid certificate
    requests.packages.urllib3.disable_warnings()

    # Start our session (need cookies for login)
    client = requests.Session()

    # Retrieve the CSRF token first
    r = client.get(login_url, verify=False)
    csrf = re.search(".*name='__csrf_magic' value=\"([^\"]+)\".*", r.text, flags=re.MULTILINE).group(1)

    # Login to the web interface
    login_data = dict(login='Login', usernamefld=args.user, passwordfld=args.password, __csrf_magic=csrf)
    r = client.post(login_url, data=login_data, verify=False)
    csrf = re.search(".*name='__csrf_magic' value=\"([^\"]+)\".*", r.text, flags=re.MULTILINE).group(1)

    # Retrieve the configuration web page and parse it
    r = client.get(args.url, verify=False)
    html = lxml.html.fromstring(r.text)

    # Save it if asked to keep files
    if args.keep:
        f = open(f'{tmpdir.name}/{module_name}.html', 'w')
        f.write(r.text)
        f.close()

elif args.urlfile is not None:
    # Use a cached copy of the web page - get rid of this?  Need to specify host and module name
    html = lxml.html.parse(args.urlfile)
    host = '192.168.100.2'
    module_name = 'pfsense_nat_1to1'

else:
    sys.exit('You must specify one of --url or --urlfile')

# Collect the /cf/conf/config.xml file
ssh = SSHClient()
ssh.load_system_host_keys()
ssh.connect(host, username='root', password=args.password)
scp = SCPClient(ssh.get_transport())
scp.get('/cf/conf/config.xml', f'{tmpdir.name}')
scp.close()

# Parse the config.xml file
root = ET.parse(f'{tmpdir.name}/config.xml').getroot()

# Search for any element with our target text, make sure we found only one
xpath = f'.//*[.="{args.item_min}"]'
key_elts = root.findall(xpath)
if len(key_elts) > 1:
    sys.exit(f'Found {len(key_elts)} items with path "{xpath}"')
elif len(key_elts) == 0:
    sys.exit(f'Cannot find minimally configured item with path "{xpath}"')
else:
    key_elt = key_elts[0]

# This element should be the key for the items
module_key = key_elt.tag

# The full node configuration element will be the parent
node_elt = key_elt.find('..')
module_node = node_elt.tag

# The "root" for this type of element is above that
root_elt = node_elt.find('..')
module_root = root_elt.tag

# Debug
print('item_min:\t' + ET.tostring(node_elt).decode())

# Let's use our node and key as a check
full_elt = root.find(f'.//{module_node}[{module_key}="{args.item_full}"]')
if full_elt is None:
    sys.exit(f'Cannot find fully configured item with path ".//{module_node}[{module_key}="{args.item_full}"]"')

# Debug
print('item_full:\t' + ET.tostring(full_elt).decode())

# Collect the items for comparison with web elements and example values
params_full = dict()
for elt in full_elt:
    if elt.tag == '':
        continue
    params_full[elt.tag] = dict()
    addr_elt = elt.find('address')
    if addr_elt is not None:
        params_full[elt.tag]['example'] = addr_elt.text
        params_full[elt.tag]['address'] = True
    elif elt.text is not None:
        params_full[elt.tag]['type'] = 'str'
        params_full[elt.tag]['example'] = elt.text.strip()
    # else:
        # Likely a bool?

if 'type' in params_full:
    module_type = params_full['type']['example']
else:
    module_type = None

print('')

# The web page should have a single form
if len(html.forms) != 1:
    sys.exit(f'Found {len(html.forms)} forms instead of a single one!')

# Collected parameters from the web form
params = dict()

# Collect the input elements
for input in html.forms[0].inputs:
    # Skip internal items
    if input.name == '__csrf_magic':
        continue

    param = dict(description='')
    print(f'attrib={input.attrib}')
    if isinstance(input, lxml.html.InputElement):
        print(f'input name={input.name} id={input.get("id")} type={input.type} value={input.value} '
              f'text={input.text} title={input.get("title")} tail={input.tail}')

        if input.type == 'checkbox':
            param['type'] = 'bool'
            param['value'] = input.attrib['value'].strip()
            param['example'] = 'true'
        elif input.type == 'number':
            param['type'] = 'int'
        elif input.type == 'password':
            param['type'] = 'str'
            param['password'] = True  # TODO - set nolog
        elif input.type == 'text':
            param['type'] = 'str'
        # TOOD - handle placeholder as 'default' value - description? create_default? example?
        for attr in ['min', 'placeholder', 'step']:
            if attr in input.attrib:
                param[attr] = input.attrib[attr]
        # Text sometimes is after the input element inside the enclosing <label>
        if input.tail:
            param['description'] = input.tail.strip()
    elif isinstance(input, lxml.html.SelectElement):
        print(f'select name={input.name} value={input.value} value_options={input.value_options} multiple={input.multiple}')
        if input.value_options is not None:
            param['choices'] = input.value_options
            if input.multiple:
                param['type'] = 'list'
            else:
                param['type'] = 'str'
            param['multiple'] = input.multiple

#  <div class="form-group">
#    <label class="col-sm-2 control-label">
#       <span class="element-required">Hostname or IP address</span>
#    </label>
#    <div class="col-sm-10">
#      <input class="form-control" name="ldap_host" id="ldap_host" type="text">
#      <span class="help-block">NOTE: When using SSL/TLS or STARTTLS, this hostname MUST match a Subject Alternative Name (SAN) or the Common Name (CN) of the LDAP server SSL/TLS Certificate.</span>
#    </div>
#  </div> 

    div1 = input.find('..')
    div2 = div1.find('..')
    if div2.tag == 'div' and div2.attrib['class'] == 'form-group':
        descr_elt = div2.find('*span')
        if descr_elt.text:
            print(f'Found descr_elt {descr_elt.tag} {descr_elt.text}')
            param['description'] += f'{descr_elt.text.strip()} of the {module_node}'
        help_elt = div1.find('span[@class="help-block"]')
        if help_elt is not None:
            print(f'help_elt text {help_elt.text.strip()}')
            param['description'] += f'. {help_elt.text.strip()}'

    params[input.name] = param

# Key is handled separately from other parameters so remove it
# TODO - keep the description, etc?
del params[module_key]

# Debug
print(f'Web paramters: {params.keys()}')

# Consistency
params_web_only = list(set(params.keys()) - set(params_full.keys()))
print('Web parameters not in xml: ' + str(params_web_only))

# Cleanup extra web parameters
for param in params_web_only:
    # See if the items are numbered, likely maps to an unnumbered XML tag
    newp = re.sub(r'0$', '', param)
    if newp != param:
        if newp in params_full:
            print(f'Renaming {param} to {newp}')
            params[newp] = params.pop(param)
            continue

    # See if the items are prefixed by a type, likely maps to un-prefixed XML tag
    newp = re.sub(f'^{module_type}_', '', param)
    if newp != param:
        if newp in params_full and newp not in params:
            print(f'Renaming {param} to {newp}')
            params[newp] = params.pop(param)
            continue

    # Common renamings
    for f, t in [('dst', 'destination'), ('src', 'source')]:
        if param == f and t in params_full:
            print(f'Renaming {f} to {t}')
            params[t] = params.pop(f)
            break
    else:
        # Otherwise, drop - probably just used to construct the final elements
        if param in params:
            print(f'Removing {param}')
            del params[param]

print('')
params_xml_only = list(set(params_full.keys()) - set(params.keys()) - {module_key, 'refid'})
print('XML parameters not in web: ' + str(params_xml_only))

for param in params_xml_only:
    params[param] = params_full[param]

# Create some sample descriptions
for name, param in params.items():
    # TODO - wrap long descriptions
    if 'description' not in param or param['description'] == '':
        param['description'] = f'The {name} of the {module_node}'
    if 'example' not in param or param['example'] == '':
        if name in params_full and 'example' in params_full[name]:
            param['example'] = params_full[name]['example']

# Template variables
context = dict(
    module_name=module_name,
    module_root=module_root,
    module_node=module_node,
    module_key=module_key,
    params=params,
    author_name=args.author_name,
    author_email=args.author_email,
    author_handle=args.author_handle,
    year=datetime.date.today().year,
)

# Render our module!
environment = jinja2.Environment(loader=jinja2.FileSystemLoader("misc/"), trim_blocks=True, keep_trailing_newline=True)
template = environment.get_template("pfsense_module.py.j2")

filename = f'plugins/modules/{module_name}.py'
if os.path.isfile(filename) and not args.force:
    sys.exit(f'{filename} already exists!')
print(f'Writing {filename} with {context}')
f = open(f'{filename}', 'w')
f.write(template.render(context))
f.close()
